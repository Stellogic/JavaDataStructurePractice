# 215. 数组中的第K个最大元素
https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。



示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4


提示：

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104


******

### 方法：维护一个大小为 k 的小顶堆

#### 核心思想

我们遍历整个数组，并始终维护一个包含 `k` 个元素的集合，这个集合里存的是我们到目前为止遇到的最大的 `k` 个数。遍历结束后，这个集合里的最小的那个数，就是整个数组中第 `k` 大的元素。

为了高效地实现这个思想，我们选择“小顶堆”作为存储这个集合的数据结构。

#### 为什么是“小顶堆”？

*   **小顶堆 (Min-Heap)**：一种数据结构，它的特点是堆顶永远是整个堆中最小的元素。
*   **为什么用它**：我们用一个大小固定为 `k` 的小顶堆来存储“目前为止最大的k个数”。堆顶的元素自然就是这 `k` 个数中最小的那个。当来了一个新数字，我们只需要将它和堆顶元素比较：
    *   如果新数字比堆顶元素还小（或相等），那它肯定没资格进入“最大的k个数”的行列，直接忽略。
    *   如果新数字比堆顶元素大，说明它更有资格。我们就把堆顶的最小元素踢出去，把这个新数字加进来，维持堆的大小仍然是 `k`。

这样，我们只需要 O(log k) 的时间就能完成一次比较和替换操作。

---

### 详细步骤

1.  **初始化**：创建一个小顶堆（在很多语言中也叫优先队列，设置为最小的元素优先级最高）。
2.  **遍历数组**：逐个处理输入数组 `nums` 中的每一个数字 `num`。
3.  **维护堆**：在处理每个数字 `num` 时，进行如下判断：
    *   **如果堆内元素不足 k 个**：直接将 `num` 放入堆中。
    *   **如果堆内元素已有 k 个**：
        *   获取堆顶元素 `top`（也就是当前已知的第 k 大的元素）。
        *   比较 `num` 和 `top`。
        *   如果 `num > top`，说明 `num` 比当前“第k大”的元素还要大，那么它有资格成为新的“k大元素”之一。此时，我们先从堆中移除堆顶元素 `top`，再将新元素 `num` 加入堆。
        *   如果 `num <= top`，说明 `num` 没有资格，我们什么都不做。
4.  **返回结果**：当遍历完整个数组后，堆里剩下的就是整个数组中最大的 `k` 个元素。而堆顶的那个元素，就是这 `k` 个数中最小的，也就是我们最终要找的**第 k 个最大的元素**。

```java
import java.util.PriorityQueue;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        for (int num : nums) {
            if (minHeap.size() < k){
                minHeap.offer(num);
            }else {
                if (num > minHeap.peek()){
                    minHeap.poll();
                    minHeap.offer(num);
                }
            }
        }
        return minHeap.peek();
    }
}
```
时间O(nlog(k))，空间O(k)

2. 快速选择

1.  对 `n` 个元素进行一次 **分区 (Partition)** 操作。这一步的成本依然是 **O(n)**。
2.  分区后，基准 (pivot) 到位，假设它的索引是 `p`。
3.  **判断 `p` 和我们目标索引的关系** (我们要找的第 k 大的元素，在排序后数组中的索引是 `n-k`)。
    *   如果 `p` 正好是 `n-k`，那么我们找到了答案，算法结束。
    *   如果 `p` 大于 `n-k`，说明目标元素在基准的**左边**。我们**只需要在左子数组中继续寻找**。
    *   如果 `p` 小于 `n-k`，说明目标元素在基准的**右边**。我们**只需要在右子数组中继续寻找**。

和快排不同的是，我们直接抛弃了一半。平均情况就是n+(n/2)+(n/4)+……+1