# 215. 数组中的第K个最大元素
https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&envId=top-100-liked
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。



示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4


提示：

1 <= k <= nums.length <= 105
-104 <= nums[i] <= 104


******

### 方法：维护一个大小为 k 的小顶堆

#### 核心思想

我们遍历整个数组，并始终维护一个包含 `k` 个元素的集合，这个集合里存的是我们到目前为止遇到的最大的 `k` 个数。遍历结束后，这个集合里的最小的那个数，就是整个数组中第 `k` 大的元素。

为了高效地实现这个思想，我们选择“小顶堆”作为存储这个集合的数据结构。

#### 为什么是“小顶堆”？

*   **小顶堆 (Min-Heap)**：一种数据结构，它的特点是堆顶永远是整个堆中最小的元素。
*   **为什么用它**：我们用一个大小固定为 `k` 的小顶堆来存储“目前为止最大的k个数”。堆顶的元素自然就是这 `k` 个数中最小的那个。当来了一个新数字，我们只需要将它和堆顶元素比较：
    *   如果新数字比堆顶元素还小（或相等），那它肯定没资格进入“最大的k个数”的行列，直接忽略。
    *   如果新数字比堆顶元素大，说明它更有资格。我们就把堆顶的最小元素踢出去，把这个新数字加进来，维持堆的大小仍然是 `k`。

这样，我们只需要 O(log k) 的时间就能完成一次比较和替换操作。

---

### 详细步骤

1.  **初始化**：创建一个小顶堆（在很多语言中也叫优先队列，设置为最小的元素优先级最高）。
2.  **遍历数组**：逐个处理输入数组 `nums` 中的每一个数字 `num`。
3.  **维护堆**：在处理每个数字 `num` 时，进行如下判断：
    *   **如果堆内元素不足 k 个**：直接将 `num` 放入堆中。
    *   **如果堆内元素已有 k 个**：
        *   获取堆顶元素 `top`（也就是当前已知的第 k 大的元素）。
        *   比较 `num` 和 `top`。
        *   如果 `num > top`，说明 `num` 比当前“第k大”的元素还要大，那么它有资格成为新的“k大元素”之一。此时，我们先从堆中移除堆顶元素 `top`，再将新元素 `num` 加入堆。
        *   如果 `num <= top`，说明 `num` 没有资格，我们什么都不做。
4.  **返回结果**：当遍历完整个数组后，堆里剩下的就是整个数组中最大的 `k` 个元素。而堆顶的那个元素，就是这 `k` 个数中最小的，也就是我们最终要找的**第 k 个最大的元素**。

```java
import java.util.PriorityQueue;

class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        for (int num : nums) {
            if (minHeap.size() < k){
                minHeap.offer(num);
            }else {
                if (num > minHeap.peek()){
                    minHeap.poll();
                    minHeap.offer(num);
                }
            }
        }
        return minHeap.peek();
    }
}
```
时间O(nlog(k))，空间O(k)

2. 快速选择

   1.  对 `n` 个元素进行一次 **分区 (Partition)** 操作。这一步的成本依然是 **O(n)**。
   2.  分区后，基准 (pivot) 到位，假设它的索引是 `p`。
   3.  **判断 `p` 和我们目标索引的关系** (我们要找的第 k 大的元素，在排序后数组中的索引是 `n-k`)。
       *   如果 `p` 正好是 `n-k`，那么我们找到了答案，算法结束。
       *   如果 `p` 大于 `n-k`，说明目标元素在基准的**左边**。我们**只需要在左子数组中继续寻找**。
       *   如果 `p` 小于 `n-k`，说明目标元素在基准的**右边**。我们**只需要在右子数组中继续寻找**。

和快排不同的是，我们直接抛弃了一半。平均情况就是n+(n/2)+(n/4)+……+1，求和后是O(N)

具体分区时，为了尽可能避免最坏情况，使用随机数

```java
import java.util.Random;

class Solution {
    private final Random random = new Random();

    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        int targetIndex = n - k;
        int left = 0;
        int right = n - 1;
        while (true){
            int pivotIndex = partition(nums,left,right);
            if (pivotIndex == targetIndex){
                return nums[pivotIndex];
            } else if (pivotIndex > targetIndex) {
                right = pivotIndex - 1;
            }else {
                left = pivotIndex + 1;
            }
        }
        
    }
    private int partition(int[]  nums,int left,int right){
        int randomIndex = random.nextInt(left,right+1);
        swap(nums,left,randomIndex);
        int i = left;
        int j = right;
        int pivot = nums[left];
        while (i < j){
            while (i < j && nums[j] >= pivot){
                j--;
            }
            if (i < j){
                nums[i] = nums[j];
            }
            while (i<j && nums[i] <= pivot){
                i++;
            }
            if (i < j){
                nums[j] = nums[i];
            }
        }
        nums[i] = pivot;
        return i;
    }
    private void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

# 347. 前 K 个高频元素
https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。



示例 1：

输入：nums = [1,1,1,2,2,3], k = 2

输出：[1,2]

示例 2：

输入：nums = [1], k = 1

输出：[1]

示例 3：

输入：nums = [1,2,1,2,1,2,3,1,3,2], k = 2

输出：[1,2]



提示：

1 <= nums.length <= 105
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的


进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。

*****
1. 小顶堆法

使用一个哈希表统计频数

类似上一道topk问题

维护一个长度k的小顶堆。如果元素数目小于k直接入堆，否则和堆顶比，只要比堆顶大，就把堆顶出堆并且这个元素入堆,直到最后就是目标的k个元素。

（注意相等的时候也不操作，因为题目保证了频率最高的k个元素是唯一的。如果堆数目满足了k，并且堆顶和待测元素相等，最终必然两个都不在最终的目标集合里）

入堆出堆复杂度都是logk，最终复杂度nlogk

空间O(n)
```java
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> frequencyMap = new HashMap<>();
        for (int num : nums){
            frequencyMap.put(num,frequencyMap.getOrDefault(num,0) + 1);
        }
        PriorityQueue<Map.Entry<Integer,Integer>> priorityQueue = new PriorityQueue<>((a,b) -> a.getValue() - b.getValue());
        for (Map.Entry<Integer,Integer> entry : frequencyMap.entrySet()){
            if (priorityQueue.size() < k){
                priorityQueue.offer(entry);
            }else {
                if (entry.getValue() > priorityQueue.peek().getValue()){
                    priorityQueue.poll();
                    priorityQueue.offer(entry);
                }
            }
        }
        int [] result = new int[k];
        for (int i = 0;i < k;i++){
            result[i] = priorityQueue.poll().getKey();
        }
        return result;
    }
} 
```


2. 桶排序

先用哈希表统计频率

之后构造桶，桶索引代表频率，里面存的是频率为索引的元素

倒叙遍历桶，取出k个为止

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }


        List<Integer>[] buckets = new List[nums.length + 1];
        for (int i = 0; i <= buckets.length;i++){
            buckets[i] = new ArrayList<Integer>();
        }
    }
}
```
