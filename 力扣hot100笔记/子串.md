# 560. 和为 K 的子数组
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。



示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2


提示：

1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107


简单的想法是，使用两层循环，外层循环确定子数组的起点，内层循环确定子数组的终点，并计算子数组的和。如果子数组的和等于 k，则计数器加一。这个时间复杂度应该是O(n^2)。

因为有很多重复计算，感觉可以动态规划。定义状态[i,j],表示从i到j的子数组的和，显然满足无后效性和最优子结构。状态转移方程是dp[i][j] = dp[i][j-1] + nums[j]。但是这样的话，时间复杂度还是O(n^2)。

正确的方法应该是前缀和。

利用前缀和。pre[i]表示从0到，i的和。那么如果[i,j]的和是k，那么pre[j] - pre[i-1] = k,即pre[i-1] = pre[j] - k。也就是说，对于我们遍历到的每个j，我们只要知道有多少个pre[i-1]等于pre[j]-k就行了。

可以用哈希表储存前缀和出现的次数。

步骤：
1. 初始化map来存放前缀和，{前缀和：出现次数}
2. 注意特殊边界，如果[0,0]子串时出现了pre[0] - pre[-1],pre[-1]没有定义，但实际上可以认为是所有元素出现之前，是0，因此可以先把{0}次数初始化为0
3. 遍历数字，依次计算当前前缀和pre[j],查看哈希表是否存在pre[j] - k，添加结果;更新或者添加pre[j]

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        int preSum = 0;
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            preSum += nums[i];
            if (map.containsKey(preSum - k)){
                result += map.get(preSum - k);
            }
            map.put(preSum,map.getOrDefault(preSum,0) + 1);//map.get(preSum)++无意义
        }
        return result;
    }
}
```
注意：
1. map.get()返回的是一个Integer对象，执行map.get()++执行了自动拆箱，相当于类似于3++，没有意义
2. 可以使用getOrDefault(key,defaultValue)方法，如果key不在就默认成defaultValue。
3. 时间复杂度O(n),空间复杂度O(n)


# 滑动窗口的最大值
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。



示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length


每次只需要比较新进来的right指向的数和当前的最大值即可。时间复杂度O(n+k),空间复杂度O(1)

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int left = 0;
        int right = left + k - 1;
        int maxInt = Integer.MIN_VALUE;
        List<Integer> result = new ArrayList<>();
        for (int i = left; i <= right; i++) {
            maxInt = Math.max(maxInt, nums[i]);
        }
        while (right < nums.length) {
            maxInt = Math.max(maxInt,nums[right]);
            result.add(maxInt);
            left++;
            right++;
        }
        return result.toArray(new Integer[0]);
    }
}
```
这个解法错误。没考虑如果左侧的出去的元素恰好是最大的元素
同时List<Integer>的列表的转换为int[],要么遍历要么使用stream

必须每个窗口都同时遍历进行求最大值，时间复杂度只能说O(nk)


下面是正确解法
## 优先队列
使用一种能O(1)查找最大值的数据结构--优先队列（通常用 堆实现）
1. 维护一个大顶堆，储存当前窗口的元素。堆顶始终是最大值
2. 窗口向右移动时，新进入的元素入堆，同时要离开的元素移除
3. 但是大顶堆只支持高效访问最大值，无法删除任意指定元素。可以储存而元素(数组，下标)。窗口移动时，查看堆顶。如果下标不在当前窗口，就弹出，继续查看新的堆顶，直到堆顶元素在窗口内

```java
import java.util.PriorityQueue;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> b[0] - a[0]);
        int[] result = new int[nums.length - k +1];
        int left = 0;
        int right = left + k - 1;
        for (int i = left;i <= right;i++){
            pq.add(new int[]{nums[i],i});
        }
        result[left] = pq.peek()[0];
        left++;
        right++;
        while (right < nums.length){
            pq.add(new int[]{nums[right],right});
            while (!(pq.peek()[1] >= left && pq.peek()[1] <= right) ){
                pq.poll();
            }
            result[left] = pq.peek()[0];
            left++;
            right++;
        }
        return result;
    }
}
```

注意：
1. 优先队列的初始化，参数应当是一个比较器。(a,b) -> returnValue 这个返回值如果为正，a在后b在前；如果为负，a在前b在后。可以这样记忆：假设a小，如果返回值是a-b,则为负，a在前，是升序（正好是默认的顺序，正好返回值a-b也是默认的顺序）；如果返回值是b-a,则为正，a在后，是降序（正好是不默认的顺序，正好b-a也不是和(a,b)相同的顺序)。

## 单调队列
使用一个双端队列。  

在每次遍历时，把队列中相比于当前元素更早出现的、更小元素直接出列（因为当前元素必定比这个元素存在的时间长，并且值大，故这个元素不可能有机会成为最大值）  

因此
1. 队列存的是下标，不是值：我们不仅要直到值，也要直到索引，方便判断是否滑出了窗口
2. 从队头到队尾，对应的值是单调递减的
3. 为了保证上面的性质，每个新元素准备入队时 ，从队尾开始向前挑战，如果队尾的元素小于等于当前元素，说明队尾元素“又小又老”，直接出队。循环这个过程，直到队尾元素比当前元素大，或者队列为空。之后当前元素入队。

```java
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] result = new int[nums.length - k + 1];
        Deque<Integer> deque = new ArrayDeque<>();
        //处理首个窗口
        int left = 0;
        int right  = left + k - 1 ;
        for (int i = left; i <= right; i++) {
            while (!deque.isEmpty() && nums[deque.getLast()] <= nums[i]){
                deque.pollLast();
            }
            deque.addLast(i);
        }
        result[0] = nums[deque.peekFirst()];
        
        right++;
        left++;
        
        
        while (right < nums.length){
            // 移除队头如果队头索引滑出
            while (deque.getFirst() < left){//用if也行，但while更好理解
                deque.pollFirst();
            }
            //维护单调递减
            while (!deque.isEmpty() && nums[deque.getLast()] <= nums[right]){
                deque.pollLast();
            }
            deque.add(right);
            result[left] = nums[deque.getFirst()];
            left++;
            right++;
        }
        
        return result;
    }
}
```
时间复杂度O(n),虽然每个窗口的里面还有一次while循环，但每个窗口的循环次数不一定，总的来看每个元素最多入队依次和出队一次
空间复杂度O(k)，因为队头索引必然时最小的。所以他必然是第一个滑出的
一个元素的下标要想留在队列里，它必须满足一个苛刻的条件：它必须比所有在它之后入队的、且仍留在队列里的元素的值都大。
队头元素：它之所以能待在队头，是因为它从入队那一刻起，直到现在，所有后来者中没有一个比它更强（或者说，比它强的后来者把它前面的所有人都清除了，但没能清除它）。它是在这场“幸存者游戏”中活得最久（索引最小）的那个强者（值最大）。
队列中的其他元素：它们都是队头的“晚辈”（索引更大）。它们之所以能留在队列里，是因为它们比自己更晚的“晚辈”要强。


## 