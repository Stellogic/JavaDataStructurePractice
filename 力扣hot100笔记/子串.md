# 560. 和为 K 的子数组
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。



示例 1：

输入：nums = [1,1,1], k = 2
输出：2
示例 2：

输入：nums = [1,2,3], k = 3
输出：2


提示：

1 <= nums.length <= 2 * 104
-1000 <= nums[i] <= 1000
-107 <= k <= 107


简单的想法是，使用两层循环，外层循环确定子数组的起点，内层循环确定子数组的终点，并计算子数组的和。如果子数组的和等于 k，则计数器加一。这个时间复杂度应该是O(n^2)。

因为有很多重复计算，感觉可以动态规划。定义状态[i,j],表示从i到j的子数组的和，显然满足无后效性和最优子结构。状态转移方程是dp[i][j] = dp[i][j-1] + nums[j]。但是这样的话，时间复杂度还是O(n^2)。

正确的方法应该是前缀和。

利用前缀和。pre[i]表示从0到，i的和。那么如果[i,j]的和是k，那么pre[j] - pre[i-1] = k,即pre[i-1] = pre[j] - k。也就是说，对于我们遍历到的每个j，我们只要知道有多少个pre[i-1]等于pre[j]-k就行了。

可以用哈希表储存前缀和出现的次数。

步骤：
1. 初始化map来存放前缀和，{前缀和：出现次数}
2. 注意特殊边界，如果[0,0]子串时出现了pre[0] - pre[-1],pre[-1]没有定义，但实际上可以认为是所有元素出现之前，是0，因此可以先把{0}次数初始化为0
3. 遍历数字，依次计算当前前缀和pre[j],查看哈希表是否存在pre[j] - k，添加结果;更新或者添加pre[j]

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,1);
        int preSum = 0;
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            preSum += nums[i];
            if (map.containsKey(preSum - k)){
                result += map.get(preSum - k);
            }
            map.put(preSum,map.getOrDefault(preSum,0) + 1);//map.get(preSum)++无意义
        }
        return result;
    }
}
```
注意：
1. map.get()返回的是一个Integer对象，执行map.get()++执行了自动拆箱，相当于类似于3++，没有意义
2. 可以使用getOrDefault(key,defaultValue)方法，如果key不在就默认成defaultValue。
3. 时间复杂度O(n),空间复杂度O(n)