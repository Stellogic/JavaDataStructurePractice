# 70. 爬楼梯

https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？



示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
   示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶


提示：

1 <= n <= 45

****
1. 动态规划

非常经典的动态规划

状态i当前在第i台阶

dp[i]表示爬到i的方法

dp[i] = dp[i-1]+dp[i-2].

从左到右填表

显然可以滚动优化

使用dp_i,dp_im1,dp_im2

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int dp_im2 = 1; // 代表 dp[i-2]
        int dp_im1 = 2; // 代表 dp[i-1]
        int dp_i = 0;
        for (int i = 3; i <= n; i++) {
            dp_i = dp_im1 + dp_im2;
            //注意更新顺序，先更新i-2,在更新i-1,防止i-1被覆盖

            dp_im2 = dp_im1;
            dp_im1 = dp_i;
        }
        return dp_i; 
    }
}
```
2. 下面是记忆化搜索

缓存：我们使用一个数组，通常称为 memo，来存储已经计算过的子问题的解。

在每次递归计算前，先检查 memo 中是否已有答案。如果有，直接返回答案，避免重复计算。

```java
import java.util.Arrays;

class Solution {
    // memo 数组用于存储 f(i) 的计算结果，-1 表示尚未计算
    int[] memo;

    public int climbStairs(int n) {
        // 初始化 memo 数组，大小为 n+1，因为我们需要存储 f(1) 到 f(n) 的结果
        memo = new int[n + 1];
        // 使用一个特殊值（如 -1）来标记尚未计算的状态
        Arrays.fill(memo, -1);
        
        return solve(n);
    }

    /**
     * 递归函数，计算爬到第 n 阶的方法数
     * @param n 当前的目标台阶
     * @return 到达第 n 阶的方法数
     */
    private int solve(int n) {
        // 1. 基本情况（递归的终止条件）
        if (n <= 1) {
            return 1; // 到达第0阶有1种方法（不动），到达第1阶有1种方法
        }
        if (n == 2) {
            return 2; // 到达第2阶有2种方法
        }

        // 2. 检查缓存中是否已有结果
        // 如果 memo[n] 不是初始值 -1，说明 solve(n) 已经被计算过，直接返回结果
        if (memo[n] != -1) {
            return memo[n];
        }

        // 3. 递归计算，并将结果存入缓存
        // 如果没有缓存，则进行递归计算
        // 状态转移方程：f(n) = f(n-1) + f(n-2)
        int result = solve(n - 1) + solve(n - 2);
        
        // 将计算结果存入 memo 数组，以便下次使用
        memo[n] = result;

        // 4. 返回结果
        return result;
    }
}
```
3. 矩阵快速幂

占位