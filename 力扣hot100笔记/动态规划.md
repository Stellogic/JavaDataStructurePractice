# 70. 爬楼梯

https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-100-liked

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？



示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
   示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶


提示：

1 <= n <= 45

****
1. 动态规划

非常经典的动态规划

状态i当前在第i台阶

dp[i]表示爬到i的方法

dp[i] = dp[i-1]+dp[i-2].

从左到右填表

显然可以滚动优化

使用dp_i,dp_im1,dp_im2

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int dp_im2 = 1; // 代表 dp[i-2]
        int dp_im1 = 2; // 代表 dp[i-1]
        int dp_i = 0;
        for (int i = 3; i <= n; i++) {
            dp_i = dp_im1 + dp_im2;
            //注意更新顺序，先更新i-2,在更新i-1,防止i-1被覆盖

            dp_im2 = dp_im1;
            dp_im1 = dp_i;
        }
        return dp_i; 
    }
}
```
2. 下面是记忆化搜索

缓存：我们使用一个数组，通常称为 memo，来存储已经计算过的子问题的解。

在每次递归计算前，先检查 memo 中是否已有答案。如果有，直接返回答案，避免重复计算。

```java
import java.util.Arrays;

class Solution {
    // memo 数组用于存储 f(i) 的计算结果，-1 表示尚未计算
    int[] memo;

    public int climbStairs(int n) {
        // 初始化 memo 数组，大小为 n+1，因为我们需要存储 f(1) 到 f(n) 的结果
        memo = new int[n + 1];
        // 使用一个特殊值（如 -1）来标记尚未计算的状态
        Arrays.fill(memo, -1);
        
        return solve(n);
    }

    /**
     * 递归函数，计算爬到第 n 阶的方法数
     * @param n 当前的目标台阶
     * @return 到达第 n 阶的方法数
     */
    private int solve(int n) {
        // 1. 基本情况（递归的终止条件）
        if (n <= 1) {
            return 1; // 到达第0阶有1种方法（不动），到达第1阶有1种方法
        }
        if (n == 2) {
            return 2; // 到达第2阶有2种方法
        }

        // 2. 检查缓存中是否已有结果
        // 如果 memo[n] 不是初始值 -1，说明 solve(n) 已经被计算过，直接返回结果
        if (memo[n] != -1) {
            return memo[n];
        }

        // 3. 递归计算，并将结果存入缓存
        // 如果没有缓存，则进行递归计算
        // 状态转移方程：f(n) = f(n-1) + f(n-2)
        int result = solve(n - 1) + solve(n - 2);
        
        // 将计算结果存入 memo 数组，以便下次使用
        memo[n] = result;

        // 4. 返回结果
        return result;
    }
}
```
3. 矩阵快速幂


整个过程分为三个核心步骤：

1.  **构建状态转移矩阵**：将递推关系 `f(n) = f(n-1) + f(n-2)` 转化为矩阵乘法的形式。
2.  **应用快速幂**：高效地计算这个矩阵的 N 次幂。
3.  **求解最终结果**：用计算出的矩阵乘以初始状态，得到最终答案。

---

### 第一步：构建状态转移矩阵

我们的目标是找到一个矩阵 `M`，它能将状态从 `n-1` 推进到 `n`。

一个“状态”通常包含递推关系中需要的所有前置项。对于 `f(n) = f(n-1) + f(n-2)`，我们需要 `f(n-1)` 和 `f(n-2)` 来计算 `f(n)`。因此，我们可以定义一个状态向量：

```
[ f(n)   ]
[ f(n-1) ]
```

我们希望找到一个 2x2 的矩阵 `M`，使得：

```
[ f(n)   ]   [ ?  ? ]   [ f(n-1) ]
[        ] = [      ] * [        ]
[ f(n-1) ]   [ ?  ? ]   [ f(n-2) ]
```

我们来填充这个矩阵 `M`：

1.  **第一行**：根据递推公式 `f(n) = 1 * f(n-1) + 1 * f(n-2)`。这告诉我们矩阵的第一行应该是 `[1, 1]`。
    ```
    f(n) = [1, 1] * [ f(n-1) ]
                    [ f(n-2) ]
    ```
2.  **第二行**：我们需要得到 `f(n-1)`。这是一个简单的恒等式：`f(n-1) = 1 * f(n-1) + 0 * f(n-2)`。这告诉我们矩阵的第二行应该是 `[1, 0]`。
    ```
    f(n-1) = [1, 0] * [ f(n-1) ]
                      [ f(n-2) ]
    ```

将它们组合起来，我们就得到了**状态转移矩阵 M**:

```
[ f(n)   ]   [ 1  1 ]   [ f(n-1) ]
[        ] = [      ] * [        ]
[ f(n-1) ]   [ 1  0 ]   [ f(n-2) ]
```

这个矩阵 `M = [[1, 1], [1, 0]]` 就是我们需要的魔法钥匙。它能将状态从 `(n-1, n-2)` 推进到 `(n, n-1)`。

---

### 第二步：应用快速幂

通过反复应用这个矩阵，我们可以从初始状态跳跃到任意的 `n` 状态。

```
[ f(3), f(2) ]^T = M * [ f(2), f(1) ]^T
[ f(4), f(3) ]^T = M * [ f(3), f(2) ]^T = M * (M * [ f(2), f(1) ]^T) = M^2 * [ f(2), f(1) ]^T
```
以此类推，我们可以得到通用公式：

```
[ f(n), f(n-1) ]^T = M^(n-2) * [ f(2), f(1) ]^T
```
*   **注意**：这里的幂是 `n-2`，因为我们是从 `f(2)` 和 `f(1)` 的状态开始跳跃 `n-2` 次到达 `f(n)` 的状态。

现在问题变成了如何快速计算 `M^(n-2)`。如果一次一次地乘，复杂度还是 O(n)。这里就要用到**快速幂算法**（也叫二进制取幂）。

它的核心思想是：
*   如果 `k` 是偶数，`A^k = (A^(k/2))^2`
*   如果 `k` 是奇数，`A^k = A * A^(k-1)`

通过这种方式，我们可以将计算 `M^k` 的时间复杂度从 O(k) 降到 O(log k)。

---

### 第三步：求解最终结果

在爬楼梯问题中，我们的初始状态是：
*   `f(1) = 1`
*   `f(2) = 2`

所以我们的初始状态向量是 `[f(2), f(1)]^T = [2, 1]^T`。

**求解 `climbStairs(n)` 的完整流程**：

1.  处理边界情况 `n <= 2`。
2.  定义转移矩阵 `M = [[1, 1], [1, 0]]`。
3.  使用快速幂算法计算 `M_result = M^(n-2)`。
4.  将结果矩阵与初始向量相乘：
    ```
    [ f(n)   ]   [ M_result[0][0]  M_result[0][1] ]   [ 2 ]
    [        ] = [                                ] * [   ]
    [ f(n-1) ]   [ M_result[1][0]  M_result[1][1] ]   [ 1 ]
    ```
5.  我们需要的答案 `f(n)` 就是结果向量的第一个元素：
    `f(n) = M_result[0][0] * 2 + M_result[0][1] * 1`

### 示例：计算 `climbStairs(4)`

1.  `n=4`，我们需要计算 `M^(4-2) = M^2`。
2.  `M = [[1, 1], [1, 0]]`
3.  `M^2 = M * M = [[1, 1], [1, 0]] * [[1, 1], [1, 0]] = [[2, 1], [1, 1]]`
4.  用 `M^2` 乘以初始向量 `[2, 1]^T`：
    ```
    [ f(4) ]   [ 2  1 ]   [ 2 ]   [ 2*2 + 1*1 ]   [ 5 ]
    [      ] = [      ] * [   ] = [             ] = [   ]
    [ f(3) ]   [ 1  1 ]   [ 1 ]   [ 1*2 + 1*1 ]   [ 3 ]
    ```
5.  最终结果 `f(4) = 5`，与我们手动计算的结果一致。

### Java 代码实现

```java
class Solution {
    public int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }

        // 状态转移矩阵
        long[][] M = {{1, 1}, {1, 0}};

        // 使用快速幂计算 M 的 n-2 次方
        long[][] M_pow_n_minus_2 = matrixPow(M, n - 2);

        // 最终结果 f(n) = M_pow[0][0] * f(2) + M_pow[0][1] * f(1)
        // f(2) = 2, f(1) = 1
        long result = M_pow_n_minus_2[0][0] * 2 + M_pow_n_minus_2[0][1] * 1;
        
        return (int) result;
    }

    // 矩阵快速幂
    private long[][] matrixPow(long[][] base, int exp) {
        // 结果矩阵初始化为单位矩阵
        long[][] result = {{1, 0}, {0, 1}};
        while (exp > 0) {
            // 如果指数是奇数，结果矩阵乘以当前的 base 矩阵
            if ((exp & 1) == 1) {
                result = multiply(result, base);
            }
            // base 矩阵自乘
            base = multiply(base, base);
            // 指数右移一位（相当于除以2）
            exp >>= 1;
        }
        return result;
    }

    // 2x2 矩阵乘法
    private long[][] multiply(long[][] a, long[][] b) {
        long[][] c = new long[2][2];
        c[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0];
        c[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1];
        c[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0];
        c[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1];
        return c;
    }
}
```
*   **时间复杂度**：O(log n)。矩阵乘法是常数时间（因为矩阵大小固定），快速幂循环 `log n` 次。
*   **空间复杂度**：O(1)。只使用了几个固定大小的矩阵变量。

# 118. 杨辉三角
https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。





示例 1:

输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
示例 2:

输入: numRows = 1
输出: [[1]]


提示:

1 <= numRows <= 30

********

状态定义为(m,n),第m行n个

dp[m][n] = dp[m-1][n-1] + dp[m-1][n]

从上往下，从左往右填表

初始化dp[0][0] = 1,dp[1][0] = 1,dp[1][1]=1

n <= m

耗费时间O(mn/2)=O(mn)

空间O(mn)