# 53.最大子数组和
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。



示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104


进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

**思考**
1. 暴力解法，双重循环，时间复杂度O(n^2)。中间很多重复
2. 考虑动态规划。状态i为当前起点索引，dp[i]为以i索引为起点的最大子数组的和。dp[i] = dp[i-1]-nums[i-1],满足最优子结构，转移顺序从左侧开始即可。显然填满dp表耗时O(n).边界条件：dp[0]先算出来。尝 试实现
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            dp[0] = Math.max(dp[0],sum);
        }
        int result = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i-1] - nums[i - 1];
            result = Math.max(dp[i],result);
        }
        return result;
    }
}
```
**上面的方法是错误的！！！！！**
 
状态转移方程，如果dp[i-1]没有包含i-1后面的数，那么这个方程错误。dp[i-1]无法提供任何信息。因此失效。无法判断dp[i-1]是否包含了i-1之后的元素。需要引入一个新的变量，这样的复杂度会成为O(n^2)  
 
正确的状态定义是，定义i为结束的索引，dp[i] = max(dp[i-1] + nums[i],nums[i])

还是从左向右转移。dp[0] = nums[0]。
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
            result = Math.max(dp[i],result);
        }
        return result;
    }
}
```
滚动优化，显然我们每次只需知道dp[i-1]
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int dp_i_1 = nums[0];
        int result = dp_i_1;
        int dp_i ;
        int temp;
        for (int i = 1; i < nums.length; i++) {
            dp_i = Math.max(dp_i_1 + nums[i],nums[i]);
            result = Math.max(dp_i,result);
            dp_i_1 = dp_i;
        }
        return result;
    }
}
```
时间复杂度O(n),空间复杂度O(1)

**下面思考分治法**


定义操作get(a,l,r),查询a序列在[l,r]的最大子段和，原问题即为：get(nums,0,nums.length - 1)

取m = (l+r)/2，对[l,m][m+1,r]分段递归

当递归深入到区间长度为1，开始回升。

关键在于如何通过[l,m]和[m+1,r]来合并[l,r]

需要明确两点：
* 维护区间哪些信息
* 如何合并信息

对于[l,r]维护四个量
* lSum，以l为端点的最大子段和
* rSum，以r为右端点的最大子段和
* maxSum，最大子段和
* iSum，区间和

如何通过两个子区间来维护？

显然长度为一的区间，四个值都是唯一的元素的值

大于1的时候：
* iSum就是iSumLeft+ iSumRight
* lSum，两种可能：
  * 等于lSumLeft
  * iSumLeft + lSumRgiht
  * 两者取最大
* rSum
  * rSumRight
  * iSumRight + rSumLeft
* maxSum：
  * 跨越m:rSumLeft + lSumRight
  * 跨越：max(maxSumLeft,maxSumRight)

```java
class Solution {
    public class Status {
        int iSum, lSum, rSum, maxSum;

        public Status(int iSum,int lSum,int rSum,int maxSum) {
            this.iSum = iSum;
            this.lSum = lSum;
            this.rSum = rSum;
            this.maxSum = maxSum;
        }
    }

    public int maxSubArray(int[] nums) {
        return getMaxSum(nums, 0, nums.length - 1).maxSum;
    }

    private Status getMaxSum(int[] a, int left, int right) {
        if (left == right){
            int temp = a[left];
            return new Status(temp,temp,temp,temp);
        }
        int m = left + (right- left) / 2;
        Status L = getMaxSum(a,left,m);
        Status R = getMaxSum(a,m + 1,right);
        return PushUp(L,R);
    }
    
    private  Status PushUp(Status L,Status R){
        int iSum = L.iSum + R.iSum;
        int lSum = Math.max(L.lSum, L.iSum + R.lSum);
        int rSum = Math.max(R.rSum,L.rSum + R.iSum);
        int maxSum = Math.max(Math.max( L.maxSum,R.maxSum),L.rSum + R.lSum);
        return new Status(iSum,lSum,rSum,maxSum);
    }
}
```

时间复杂度：递推式：T(n) = 2T(n/2) + O(1)，由主定理O(N).也可以递归树，高度logn，相当于对每个节点执行一次O(1)pushUp操作，节点数2^0 + 2^1 + ... + 2^logn = 2n - 1 = O(n)
空间复杂度O(logn),递归栈深度


**前缀和法**
对于从i到j的数组，其和实际上就是pre[j] - pre[i-1].在固定j的时候，求最大值就是求pre[i-1] (贪心策略)，贪心的正确性是显然的。

每次遍历，维护min_pre,preCur,result.，可以认为pre[-1] = 0.

```java
class Solution {
    public int maxSubArray(int[] nums) {
      int min_pre = 0;//认为pre[-1]为0
      int preCur = 0;
      int result = Integer.MIN_VALUE;
      for (int i = 0; i < nums.length; i++) {
        preCur += nums[i];
        result = Math.max(result,preCur - min_pre);
        min_pre = Math.min(preCur,min_pre);// 注意必须在更新result后更新结果！min_pre要确保是cur前面的最小的，不应该和precur重合
      }
      return result;
      
    }
}
```
# 合并区间
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。



示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
示例 3：

输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。


提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104



思考：先按照每个区间的大的数进行升序排序，之后依次遍历即可。复杂度O(nlogn)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
  public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, (int[] a, int[] b) -> a[1] - b[1]);
    List<List<Integer>> resultList = new ArrayList<>();
    for (int i = 0; i < intervals.length - 1; i++) {
      if (intervals[i][1] >= intervals[i + 1][0]) {
        resultList.add(new ArrayList<>({intervals[i][0],intervals[i+1][1]}));
      }
    }
  }
}
```
上面思路整体接近但实现卡壳。但最好来说是按照区间起始位置排序更好。[1,9],[5,6],[0,4],[10,11]，如果按照结束位置会是，[0,4],[5,6],[1,9],[10,11],但是按照起始位置是[0,4],[1,9],[5,6],[10,11]，虽然实际上都可以，但为了方便从左向右遍历，我们最好按照起始元素排序

同时对于具体实现，先把首个区间加入链表，之后如果有重叠就修改上一个区间的右边界（因为按照左边界的排序，左边界一定不用动）

```java
class Solution {
  public int[][] merge(int[][] intervals) {
      if (intervals.length == 0){
          return new int[0][2];
      }
      Arrays.sort(intervals, (int[] a, int[] b) -> a[0] - b[0]);
      List<int[]> resultList = new ArrayList<>();
      resultList.add(intervals[0]);
      for (int i = 1; i < intervals.length; i++) {
  
        if (intervals[i][0] <= resultList.get(resultList.size() - 1)[1]){
          resultList.get(resultList.size() - 1)[1] = Math.max(intervals[i][1],resultList.get(resultList.size() - 1)[1]);
        }else {
          resultList.add(intervals[i]);
        }
      }
      return resultList.toArray(new int[][]{});
    }
}

```
时间复杂度O(nlogn),空间复杂度O(n)

注意，List<Integer>转换为int[]只能遍历或者stream，但转换为Integer[]不必，直接调用方法传入长度为0的数组即可。


# 189.轮转数组
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。



示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释:
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]


提示：

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
0 <= k <= 105


进阶：

尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

**思考**

一个简单的想法就是依次遍历向后移动，(i+k)%nums.length，同时要用数组记录被覆盖的那个数并且维护一个布尔数组表示索引处是否被交换过,时间O(n)空间O(n)

更好的方法是使用**额外数组**。把原本的数组直接按照(i+k)%nums.length复制到新数组里面，最后再把新数组复制回来。时空复杂度都是O(n)

下面是O(n)O(1)解法
1. **数组翻转**
   先把数组分为两部分，前n-k个，记为A，后k个，记为B，原本数组是A+B,显然我们的目标是转换成B+A。先进行一次整体翻转，成为rev(B)+rev(A),再分别对BA反转，成为B+A
```java
class Solution {
    public void rotate(int[] nums, int k) {
        k = k% nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
        return;
    }
    private int[] reverse(int[] nums,int left,int right){
        if (nums.length <= 1){
            return nums;
        }
        int temp;
        while (left < right){
            temp = nums[right];
            nums[right] = nums[left];
            nums[left] = temp;
            left++;
            right--;
        }
        return nums;
    }
}
```
时间复杂度O(n)


2. **环状替换**

第一次冲0开始，把next_index = (0+k)%nums.length和他互换，使用temp储存被替换的值，之后开始把next_index（值存到了temp里面）和(next_index+k)%nums.length互换，存值，重复。直到回到起点。

但这样，一次遍历其实不一定能够遍历所有元素进行互换。

假设一共跑了a圈，则总路程是an；假设跳跃了b次（b个元素被替换），路程是bk。则an=bk,显然总路程要最小也就是lcm(n,k).则b = lcm(n,k)/k,那么就要循环n/b = (nk)/lcm(n,k)= gcd(n,k)次  

也可以抛开数论，引入一个变量count记录被替换的数目，当count = n时停止

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        
        // 处理 k=0 的边界情况，避免不必要的循环
        if (k == 0) {
            return;
        }

        int count = 0; // 记录已归位的元素数量
        
        // for 循环结构更清晰地表达了“为每个环寻找起点”的意图
        // 只要还没处理完 n 个元素，就从下一个 start 开始尝试
        for (int start = 0; count < n; start++) {
            int current = start;
            int prev = nums[start]; // prev 在每个新环开始时初始化

            do {
                int next = (current + k) % n;
                int temp = nums[next];
                nums[next] = prev;
                prev = temp;
                current = next;
                count++; // 每归位一个元素，计数器加一
            } while (start != current); // 当回到环的起点时，内层循环结束
        }
    }
}
```
时间复杂度：遍历了每个元素执行了O(1)的替换。因此是O(n)