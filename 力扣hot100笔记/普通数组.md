# 53.最大子数组和
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。



示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [5,4,-1,7,8]
输出：23


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104


进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

**思考**
1. 暴力解法，双重循环，时间复杂度O(n^2)。中间很多重复
2. 考虑动态规划。状态i为当前起点索引，dp[i]为以i索引为起点的最大子数组的和。dp[i] = dp[i-1]-nums[i-1],满足最优子结构，转移顺序从左侧开始即可。显然填满dp表耗时O(n).边界条件：dp[0]先算出来。尝 试实现
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            dp[0] = Math.max(dp[0],sum);
        }
        int result = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i-1] - nums[i - 1];
            result = Math.max(dp[i],result);
        }
        return result;
    }
}
```
**上面的方法是错误的！！！！！**
 
状态转移方程，如果dp[i-1]没有包含i-1后面的数，那么这个方程错误。dp[i-1]无法提供任何信息。因此失效。无法判断dp[i-1]是否包含了i-1之后的元素。需要引入一个新的变量，这样的复杂度会成为O(n^2)  
 
正确的状态定义是，定义i为结束的索引，dp[i] = max(dp[i-1] + nums[i],nums[i])

还是从左向右转移。dp[0] = nums[0]。
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
            result = Math.max(dp[i],result);
        }
        return result;
    }
}
```
滚动优化，显然我们每次只需知道dp[i-1]
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int dp_i_1 = nums[0];
        int result = dp_i_1;
        int dp_i ;
        int temp;
        for (int i = 1; i < nums.length; i++) {
            dp_i = Math.max(dp_i_1 + nums[i],nums[i]);
            result = Math.max(dp_i,result);
            dp_i_1 = dp_i;
        }
        return result;
    }
}
```
时间复杂度O(n),空间复杂度O(1)

**下面思考分治法**


定义操作get(a,l,r),查询a序列在[l,r]的最大子段和，原问题即为：get(nums,0,nums.length - 1)

取m = (l+r)/2，对[l,m][m+1,r]分段递归

当递归深入到区间长度为1，开始回升。

关键在于如何通过[l,m]和[m+1,r]来合并[l,r]

需要明确两点：
* 维护区间哪些信息
* 如何合并信息

对于[l,r]维护四个量
* lSum，以l为端点的最大子段和
* rSum，以r为右端点的最大子段和
* maxSum，最大子段和
* iSum，区间和

如何通过两个子区间来维护？

显然长度为一的区间，四个值都是唯一的元素的值

大于1的时候：
* iSum就是iSumLeft+ iSumRight
* lSum，两种可能：
  * 等于lSumLeft
  * iSumLeft + lSumRgiht
  * 两者取最大
* rSum
  * rSumRight
  * iSumRight + rSumLeft
* maxSum：
  * 跨越m:rSumLeft + lSumRight
  * 跨越：max(maxSumLeft,maxSumRight)

```java
class Solution {
    public class Status {
        int iSum, lSum, rSum, maxSum;

        public Status(int iSum,int lSum,int rSum,int maxSum) {
            this.iSum = iSum;
            this.lSum = lSum;
            this.rSum = rSum;
            this.maxSum = maxSum;
        }
    }

    public int maxSubArray(int[] nums) {
        return getMaxSum(nums, 0, nums.length - 1).maxSum;
    }

    private Status getMaxSum(int[] a, int left, int right) {
        if (left == right){
            int temp = a[left];
            return new Status(temp,temp,temp,temp);
        }
        int m = left + (right- left) / 2;
        Status L = getMaxSum(a,left,m);
        Status R = getMaxSum(a,m + 1,right);
        return PushUp(L,R);
    }
    
    private  Status PushUp(Status L,Status R){
        int iSum = L.iSum + R.iSum;
        int lSum = Math.max(L.lSum, L.iSum + R.lSum);
        int rSum = Math.max(R.rSum,L.rSum + R.iSum);
        int maxSum = Math.max(Math.max( L.maxSum,R.maxSum),L.rSum + R.lSum);
        return new Status(iSum,lSum,rSum,maxSum);
    }
}
```

时间复杂度：递推式：T(n) = 2T(n/2) + O(1)，由主定理O(N).也可以递归树，高度logn，相当于对每个节点执行一次O(1)pushUp操作，节点数2^0 + 2^1 + ... + 2^logn = 2n - 1 = O(n)
空间复杂度O(logn),递归栈深度


**前缀和法**
对于从i到j的数组，其和实际上就是pre[j] - pre[i-1].在固定j的时候，求最大值就是求pre[i-1] (贪心策略)，贪心的正确性是显然的。

每次遍历，维护min_pre,preCur,result.，可以认为pre[-1] = 0.

```java
class Solution {
    public int maxSubArray(int[] nums) {
      int min_pre = 0;//认为pre[-1]为0
      int preCur = 0;
      int result = Integer.MIN_VALUE;
      for (int i = 0; i < nums.length; i++) {
        preCur += nums[i];
        result = Math.max(result,preCur - min_pre);
        min_pre = Math.min(preCur,min_pre);// 注意必须在更新result后更新结果！min_pre要确保是cur前面的最小的，不应该和precur重合
      }
      return result;
      
    }
}
```
# 合并区间
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。



示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
示例 3：

输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。


提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104



思考：先按照每个区间的大的数进行升序排序，之后依次遍历即可。复杂度O(nlogn)

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
  public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, (int[] a, int[] b) -> a[1] - b[1]);
    List<List<Integer>> resultList = new ArrayList<>();
    for (int i = 0; i < intervals.length - 1; i++) {
      if (intervals[i][1] >= intervals[i + 1][0]) {
        resultList.add(new ArrayList<>({intervals[i][0],intervals[i+1][1]}));
      }
    }
  }
}
```
上面思路整体接近但实现卡壳。但最好来说是按照区间起始位置排序更好。[1,9],[5,6],[0,4],[10,11]，如果按照结束位置会是，[0,4],[5,6],[1,9],[10,11],但是按照起始位置是[0,4],[1,9],[5,6],[10,11]，虽然实际上都可以，但为了方便从左向右遍历，我们最好按照起始元素排序

同时对于具体实现，先把首个区间加入链表，之后如果有重叠就修改上一个区间的右边界（因为按照左边界的排序，左边界一定不用动）

```java
class Solution {
  public int[][] merge(int[][] intervals) {
      if (intervals.length == 0){
          return new int[0][2];
      }
      Arrays.sort(intervals, (int[] a, int[] b) -> a[0] - b[0]);
      List<int[]> resultList = new ArrayList<>();
      resultList.add(intervals[0]);
      for (int i = 1; i < intervals.length; i++) {
  
        if (intervals[i][0] <= resultList.get(resultList.size() - 1)[1]){
          resultList.get(resultList.size() - 1)[1] = Math.max(intervals[i][1],resultList.get(resultList.size() - 1)[1]);
        }else {
          resultList.add(intervals[i]);
        }
      }
      return resultList.toArray(new int[][]{});
    }
}

```
时间复杂度O(nlogn),空间复杂度O(n)

注意，List<Integer>转换为int[]只能遍历或者stream，但转换为Integer[]不必，直接调用方法传入长度为0的数组即可。