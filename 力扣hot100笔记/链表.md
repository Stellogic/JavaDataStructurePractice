# 160.相交链表
https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：



题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
listA - 第一个链表
listB - 第二个链表
skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数
评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。



示例 1：



输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。


示例 2：



输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
示例 3：



输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：No intersection
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。


提示：

listA 中节点数目为 m
listB 中节点数目为 n
1 <= m, n <= 3 * 104
1 <= Node.val <= 105
0 <= skipA <= m
0 <= skipB <= n
如果 listA 和 listB 没有交点，intersectVal 为 0
如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]


进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

一个想法：分别遍历AB，使用一个Set保存遍历过的节点。如果某次遍历得到的节点在Set里，就是第一个相交的节点。如果某个链表遍历到尾部，则没有相交节点。

时间复杂度O(m+n),空间O(m)

```java
import java.util.HashSet;
import java.util.Set;

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

 public class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {
          val = x;
          next = null;
      }
  }

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode cur_a = headA;
        ListNode cur_b = headB;
        Set<ListNode> set = new HashSet<>();
        while (cur_a != null){
            set.add(cur_a);
            cur_a = cur_a.next;
        }
        while (cur_b != null){
            if (set.contains(cur_b)){
                return cur_b;
            }
            set.add(cur_b);
            cur_b = cur_b.next;
        }
        return null;
    }
}
```

进阶:
双指针。
p_a,和p_b。

同时移动两个指针：
* 如果某个指针为空，比如p_a为空，则把p_a指向b的开头
* 当两个指针都为空或者指向同一个节点，则返回这个相交节点或者null

实际上，就是两个指针都要遍历两个链表。
* 如果两个链表有交点，相交后的长度记为l，则p_a遍历了skip_a + l + skip_b,p_b遍历了skip_b + l + skip_a,两个指针肯定会某个时间指向同一个
* 如果没有交点，则都遍历l_a + l_b，最终同时为null

时间复杂度O(m + n),空间O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p_a = headA;
        ListNode p_b = headB;
        while (true){
            if (p_a == p_b){
                return p_a;
            }
            p_a = p_a == null ? headB : p_a.next;// 如果用if来写，注意要使用else，防止在p_a为null时，直接把p_a移动到了p_a.next
            p_b = p_b == null ? headA : p_b.next;
        }
    }
}
```
# 206.翻转链表
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。


示例 1：


输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
示例 2：


输入：head = [1,2]
输出：[2,1]
示例 3：

输入：head = []
输出：[]


提示：

链表中节点的数目范围是 [0, 5000]
-5000 <= Node.val <= 5000


进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

1. 递归
遍历找到最后一个，headNew = 最后一个

基本情况：节点数量是1，即head.next == nul，直接返回

本层问题：cur = head,next = cur.next,next_next = next.next,next.next = cur

递归处理：next_next以及之后的

最后 next_next.next = cur.

时间复杂度：O(n),空间复杂度O(n)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

public class ListNode {
     int val;
     ListNode next;
     ListNode() {}
     ListNode(int val) { this.val = val; }
     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }

class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next ==null){
            return head;
        }
        ListNode cur = head;
        while (cur.next != null){
            cur = cur.next;
        }
        ListNode headNew = cur;
        reverseListReverse(head);
        return headNew;
    }
    private void reverseListReverse(ListNode head){
        if (head.next == null){
            return;
        }
        if (head.next.next == null) {
            ListNode cur = head;
            ListNode next = cur.next;
            cur.next = null;
            next.next = cur;
            return;
        }
        ListNode cur = head;
        ListNode next = cur.next;
        ListNode next_next = next.next;
        cur.next = null;
        next.next = cur;
        reverseListReverse(next_next);
        next_next.next = next;

    }
}
```
上面解法是可以的。

但最好的还是

**先翻转head之后的链表。**

**之后让head.next指向head并把head.next赋值为null**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}


class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }
        ListNode headNew = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return headNew;
    }
}
```

2. 迭代

对遍历，对每个节点执行操作。cur和prev记录当前和上一个。Listnode next = cur.next,(防止覆盖）cur.next = prev,prev = cur,cur = cur.next.直到cur为null，prev为此时头节点
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */


public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}


class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head;
        ListNode prev = null;
        while (cur != null){
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur =next;
        }
        return prev;
    }
}
```
时间复杂度O(n),空间O(1)

# 234.回文链表
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。



示例 1：


输入：head = [1,2,2,1]
输出：true
示例 2：


输入：head = [1,2]
输出：false


提示：

链表中节点数目在范围[1, 105] 内
0 <= Node.val <= 9


进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

一个想法是，先正向遍历，用一个数组记录。之后把它逆转（其实把数组逆转就行，也可以使用双指针不去逆转数组）。再次遍历记录到一个数组。最后比较两个数组

时间复杂度O(n),空间复杂度O(n).

下面用双指针

```java
import java.util.ArrayList;
import java.util.List;

class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> temp = new ArrayList<>();
        ListNode cur = head;
        while (cur != null){
            temp.add(cur.val);
            cur = cur.next;
        }
        int left = 0;
        int right = temp.size() - 1;
        while (left < right){
            if (temp.get(left) != temp.get(right)){
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

为什么要这样转成数组？

数组可以O(1)任意访问，链表不可以。正向反向都是O(n)。想要访问最后一个元素，倒数第二个，倒数第三个都需要一次遍历到

我们可以使用递归倒叙遍历
```
function print_values_in_reverse(ListNode head)
    if head is NOT null
        print_values_in_reverse(head.next)
        print head.val
```
实现的话，frontPointer来作为从前向后遍历的指针，curNode作为从后向前遍历的指针。递归调用栈依然是O(n),时间复杂度也是O(n),因为用了递归实际上比上面解法更差
```java
class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
class Solution{
    private ListNode frontPointer;
    private boolean recursivelyCheck(ListNode curNode){
        if (curNode == null){
            //基本情况，默认为true
            return true;
        }
        boolean isInnerPartPalindrome = recursivelyCheck(curNode.next);//递归调用，判断之前的是不是回文
        if (isInnerPartPalindrome == false){
            //如果以前已经不是，直接false
            return false;
        }
        //判断本层
        ListNode frontCur = frontPointer;
        frontPointer = frontPointer.next;
        return frontCur.val == curNode.val;
    }
    public boolean isPalindrome(ListNode head){
        frontPointer = head;
        return recursivelyCheck(head);
    }
}
```
3. 满足进阶要求的方法

其实只要把后半段链表翻转，之后和前半段链表比较即可。

可以先遍历一遍计算节点个数，但更好的是使用快慢指针，慢指针一次走一步，快指针一次走两步，快指针到末尾（无法再向后走两步），慢指针就到了前半部分链表的末尾。

如果是奇数个，中间的节点认为是前半部分的末尾。

把后半部分节点进行翻转

之后开始比较即可,注意后半部分为空就停止，这样可以避免比较中心节点

最好的话最后把后半部分再翻转回来

```java
import java.util.List;

class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null ){
            return true;
        }
        ListNode endOfFirstListPointer = endOfFirstList(head);
        ListNode startOfLastListReversedListPointer = reverse(endOfFirstListPointer.next);
        ListNode firstPointer = head;
        ListNode lastPointer = startOfLastListReversedListPointer;
        while (lastPointer != null){
            if (firstPointer.val != lastPointer.val){
                return false;
            }
            firstPointer = firstPointer.next;
            lastPointer = lastPointer.next;
        }
        ListNode startOfLastListRightOrder = reverse(startOfLastListReversedListPointer);
        return true;
    }

    private ListNode reverse(ListNode head) {
        ListNode cur = head;
        ListNode prev = null;
        while (cur != null){
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
    
    private ListNode endOfFirstList(ListNode head){
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null){//检查fast即可，要先检查fast.next是否是null
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```
 