# 两数之和

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rem = new HashMap<>();
        int l = nums.length;
        for (int i = 0; i < l; i++) {
            rem.put(nums[i], i);
        }
        for (int i = 0; i < l; i++) {
            int left = target - nums[i];
            if (rem.containsKey(left) && rem.get(left) != i) {
                return new int[] {i,rem.get(left)};
            }
        }
        return null;
    }
}
```
1. 数组越界问题，注意遍历时不能取等
2. 返回值是int数组，new int[]{}即可
3. 注意循环判断时要判断rem.get(left) != i，确认不是同一个索引

优化成一遍遍历

```java
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rem = new HashMap<>();
        int l = nums.length;
        for(int i = 0;i < l;i++)
        {
            int complement = target - nums[i];
            if(rem.containsKey(complement)){
                return new int[]{rem.get(complement),i};
            }
            rem.put(nums[i],i);
        }
        return new int[0];
    }
}
```

## 字母异位词分组
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

1. 排序

    把每个单词按照字母序排序，把排序后的字符串作为key，列表为值，原字符串为列表的一部分。显然字母异位词key相同
    
    ```java
    import java.util.*;
    
    class Solution {
        public List<List<String>> groupAnagrams(String[] strs) {
            Map<String, List<String>> map = new HashMap<>();
            for (String word : strs) {
                char[] charArray = word.toCharArray();
                Arrays.sort(charArray);
                String sortedString = new String(charArray);
                if (map.containsKey(sortedString)) {
                    map.get(sortedString).add(word);
                } else {
                    List<String> temp = new ArrayList<>();
                    temp.add(word);
                    map.put(sortedString,temp);
                }
            }
            return new ArrayList<>(map.values());
        }
    }
    ```
    时间复杂度O(nklogk),n个字符串，字符串最大长度k
    
    空间复杂度O(nk)
    
    注意；
    1. List列表是个接口，ArrayList和LinkedList(双向链表)是他的实现类
    2. ？是通配符，？extends E代表E以及子类
    3. collection也是个接口，定义了add，remove,size,isEmpty,contains等方法。List,Set,Queue，都是实现类
    4. Java中String和字符数组不同（c中没有string，只有字符数组实际上）。Java中String是个对象，内部实现封装了一个字符数组（或者byte[])，有不可变性（一旦创建不可改变），和chat[]可以通过方法互相转换

2. 计数
key代表表示字母频率的唯一标识，将频率数组转换成特殊的字符串。  
遍历输入的字符串数组中的每一个字符串，每个字符串创建一个长度26的整型数组，遍历每个字符串创建一个整型数组记录频率，之后转换成频率字符串

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String word : strs) {
            int[] count = new int[26];
            for (char c : word.toCharArray()) {
                count[c - 'a']++;
            }
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (count[i] != 0) {
                    sb.append((char) ('a' + i));
                    sb.append(count[i]);
                }
            }
            String key = sb.toString();
            if (!map.containsKey(key)) {
                map.put(key, new ArrayList<>());
            }
            map.get(key).add(word);
        }
        return new ArrayList<>(map.values());
    }
}
```
时间复杂度O(nk),k是最长字符串长度  
空间复杂度O(nk)
注意：  
StringBuilder类（非线程安全）
1. 可变
2. 频繁修改字符串性能高与string
3. 丰富方法：添加插入删除反转等
Java的String也可以进行加法运算（实际上是字符串拼接），但实际上是创建了新的对象

## 最长连续序列
自己想法

```java
import java.util.HashSet;
import java.util.Set;

class Solution {
   public int longestConsecutive(int[] nums) {
       if(nums.length <= 1)
       {
           return nums.length;
       }
      Set<Integer> integerSet = new HashSet<>();
      int min = nums[0];
      int max = nums[0];
      for (int i : nums) {
          //把元素的值填入set
         if(!integerSet.contains(i))
         {
             integerSet.add(i);
         }
         if(i < min)
         {
             min = i;
         }
         if(i > max)
         {
             max = i;
         }
      }
      if(max == min)
      {
          return 1;
      }
      int[] counts = new int[max - min];
      int j = 0;
      for (int i = min; i < max ; i++) {
         if(integerSet.contains(i+1))
         {
             counts[j]++;
         }else {
             j++;
         }
      }
      int maxNum = counts[0];
      for (int i : counts) {
         if(maxNum < i)
         {
             maxNum = i;
         }
      }
      return maxNum + 1;
      
   }
}

```

上面 不太对，尤其是[1,100]无法通过，而且复杂度过高,下面优化   
1. 对原数组的元素进行遍历即可。每个num先看看num-1是否在，不在的话是个起点，开始遍历+1+2+3……。如果在的话跳过
2. 每次得到一个长度直接和当前长度比较，取最大的，不必建立数组储存全部

```java
import java.util.HashSet;
import java.util.Set;

class Solution {
   public int longestConsecutive(int[] nums) {
      Set<Integer> integers = new HashSet<>();
      for (int i : nums) {
         integers.add(i);
      }
      int result = 0;
      for (int num : nums) {
         if(!integers.contains(num - 1)) {
             int curnum = num;
             int resultThisLoop = 1;
             while (integers.contains(curnum + 1)) {
                 resultThisLoop++;
                 curnum++;
             }
             result = Math.max(result,resultThisLoop);
         }
      }
      return result;
   }
}
```
实际上来说直接遍历哈希集合就行，
```java
import java.util.HashSet;
import java.util.Set;

class Solution {
   public int longestConsecutive(int[] nums) {
      Set<Integer> integers = new HashSet<>();
      for (int i : nums) {
         integers.add(i);
      }
      int result = 0;
      for (int num : integers) {
         if(!integers.contains(num - 1)) {
             int curnum = num;
             int resultThisLoop = 1;
             while (integers.contains(curnum + 1)) {
                 resultThisLoop++;
                 curnum++;
             }
             result = Math.max(result,resultThisLoop);
         }
      }
      return result;
   }
}

```