# 94.二叉树的中序遍历
https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked
给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

提示：

树中节点数目在范围 [0, 100] 内
-100 <= Node.val <= 100


进阶: 递归算法很简单，你可以通过迭代算法完成吗？

***

1. 递归

中序遍历就是先左->当前->右

```java
import java.util.ArrayList;
import java.util.List;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    private List<Integer> TreeNodeList = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        return inorderHelper(root);
    }

    private List<Integer> inorderHelper(TreeNode root) {
        if (root == null){
            return TreeNodeList;
        }
        inorderHelper(root.left);
        TreeNodeList.add(root.val);
        inorderHelper(root.right);
        return TreeNodeList;
    }
}
```
时空复杂度都是O(n)

2. 迭代

递归隐式维护了一个栈，迭代就要显式维护一个栈

依次向左遍历，并把元素依次入栈，直到左孩子为空，开始依次出栈，直到栈空；

之后出栈一个，这个即为要处理的当前元素，把它加入结果后再开始对右子树准备处理右子树

```java
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {

    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();//pop是出栈
            result.add(cur.val);
            cur = cur.right;
        }
        return result;
    }
}
```
时空依然都是O(n)

3. Morris 中序遍历

考虑使用二叉树本身的结构来替代栈，从而降低空间复杂度

上面的空间复杂度的核心是，当我们遍历完左侧，需要用栈（或者调用栈）来记录我们要回到哪个节点

可以考虑使用前驱节点来替代（中序遍历当前节点的上一个，也就是左子树的最右侧节点），让它指向当前节点即可

```java
import java.util.ArrayList;
import java.util.List;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        while (root != null){
            if (root.left != null){
                TreeNode predecessor = root.left;
                while (predecessor.right != null && predecessor.right != root){
                    predecessor = predecessor.right;
                }
                if (predecessor.right == null){
                    predecessor.right = root;
                    root = root.left;
                }else {//左树已经访问完了
                    predecessor.right = null;
                    result.add(root.val);
                    root = root.right;
                }
            }else {
                result.add(root.val);
                root = root.right;
            }
        }
        return result;
    }
}
```
把这个再看看吧

# 104. 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked
给定一个二叉树 root ，返回其最大深度。

二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。



示例 1：

输入：root = [3,9,20,null,null,15,7]
输出：3
示例 2：

输入：root = [1,null,2]
输出：2


提示：

树中节点的数量在 [0, 104] 区间内。
-100 <= Node.val <= 100

***

深度优先搜索。简单的想法就是深度优先，同时记录长度，每次遍历到叶节点更新一次长度。

一般的深度优先采取的是递归，很难记录到达叶节点的位置。

1. 深度优先搜索

如果使用递归深度优先，考虑分解。

最高高度 = max(左子树高度，右子树高度) + 1。

基本情况就是root == null返回0

时间复杂度：平均的话是T(n) = 2T((n-1)/2) + O(1) 。本地O（1），子问题n^(log2_2) 就是n，因此最终时间复杂度O(n)。也可以直接整体分析，每次对每个节点的调用本地操作都是O(1),但是要对每个节点调用一次。

空间复杂度：调用栈最多调用二叉树高度，最差是O(n)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
 public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }

class Solution {
    public int maxDepth(TreeNode root) {
        return maxDepthHelp(root);
    }
    private int maxDepthHelp(TreeNode root){
        if (root == null){
            return 0;
        }
        return Math.max(maxDepthHelp(root.left),maxDepthHelp(root.right)) + 1;
    }
}
```
2. 广度优先

```java
List<Integer> levelOrder(TreeNode root) {
    //初始化一个队列,作为遍历过程中的临时储存。
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    //初始化一个列表储存结果
    List<Integer> result = new ArrayList<>();
    while (!queue.isEmpty())
    {
        TreeNode node = queue.poll();//出队
        result.add(node.val);
        if(node.left != null){
            queue.offer(node.left);
        }
        if(node.right != null)
        {
            queue.offer(node.right);
        }
    }
    return result;
}

```
也可以采用广度优先,上面是标准的广度优先遍历

广度优先搜索要先进先出，采用queue。每搜索一层，高度+1.关键在于怎么判断搜索完了一层。

可以在每次循环的开始，先获取当前queue中的元素个数，这个实际上就是本层的个数。然后采用for循环，直接把这层的元素全部出队并把对应的子节点放入，同时depth++即可。

```java
 import java.util.LinkedList;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null){
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();//双向链表的队列实现
        int depth = 0;
        queue.add(root);
        while (!queue.isEmpty()){
            int thisLevelSize = queue.size();
            for (int i = 0; i < thisLevelSize; i++) {
                TreeNode node = queue.poll();
                if (node.left != null){
                    queue.add(node.left);
                }
                if (node.right != null){
                    queue.add(node.right);
                }
            }
            depth++;
        }
        return depth;
    }
}

```
时空都是O(n)

注意：

| 操作 | `LinkedList` (双向链表) | `ArrayDeque` (循环数组) | 解释 |
| :--- | :--- | :--- | :--- |
| **入队 (add/offer)** | **O(1)** | **Amortized O(1)** | `LinkedList` 只是在尾部添加一个新节点并更新指针。`ArrayDeque` 在数组尾部添加元素，绝大多数情况是 O(1)，但如果数组满了，需要进行一次 O(n) 的扩容和复制操作。不过，由于扩容不是每次都发生，所以平摊下来（Amortized）的时间复杂度是 O(1)。 |
| **出队 (poll/remove)** | **O(1)** | **O(1)** | `LinkedList` 只是移除头节点并更新指针。`ArrayDeque` 只是移动头指针的索引，并不会移动数组中的其他元素，所以也是 O(1)。 |
| **内存使用** | **更高** | **更低** | 这是 `ArrayDeque` 的巨大优势。`LinkedList` 的每个元素都需要一个额外的 `Node` 对象来包装，这个对象本身以及它内部的 `prev` 和 `next` 引用都会占用额外的内存。而 `ArrayDeque` 直接将对象存储在数组中，内存开销小得多。 |
| **CPU 缓存友好度** | **差** | **好** | 这是另一个关键性能优势。`ArrayDeque` 的元素在内存中是连续存储的，这使得 CPU 在访问一个元素后，可以很高效地预加载它旁边的元素到高速缓存（Cache）中，这被称为“缓存局部性”（Cache Locality）。而 `LinkedList` 的节点在内存中是分散的，访问下一个节点可能会导致“缓存未命中”（Cache Miss），需要从主内存中重新加载，速度慢得多。 |

实际上这里最好用ArrayDeque来作为实现更好。

# 226. 翻转二叉树
https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
示例 2：
输入：root = [2,1,3]
输出：[2,3,1]
示例 3：

输入：root = []
输出：[]


提示：

树中节点数目范围在 [0, 100] 内
-100 <= Node.val <= 100

***
简单的想法就是分治递归：

翻转左子树，翻转右子树，再把左右子树调换（翻转本层）。

基本情况：如果是null，直接返回

时间复杂度：每个节点要调用一次，每次本地操作成本是O(1),因此总体是O(n)

空间复杂度：调用高度次，因此O(h),最差就是O(n)

```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode leftOld = invertTree(root.left);
        TreeNode rightOld = invertTree(root.right);
        root.left = rightOld;
        root.right = leftOld;
        return root;
    }
}
```
2. 使用栈来代替函数调用栈

上面实际上是深度优先搜索。可以使用一个栈来代替函数调用栈，把迭代转换成递归

具体来说，使用循环，每次只要栈不为空，就把节点出栈，把它的左右子节点交换，之后再把子节点入栈。

```java
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Stack;

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode cur = stack.pop();

            TreeNode temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;

            if (cur.left != null) {
                stack.push(cur.left);
            }
            if (cur.right != null) {
                stack.push(cur.right);
            }
        }
        return root;
    }
}

```
注意： Java中使用ArrayDeque来实现栈最好，但是ArrayDeque没有实现接口stack，一般使用deque作为栈即可，不适用stack接口。

上面使用栈的解法相当于是前序遍历。

3. 广度优先搜索

也可以使用广度优先

创建一个队列

把root放入

队列中取出一个节点，cur非null则交换子节点

之后把cur子节点入队

```java
import java.util.ArrayDeque;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode cur = queue.poll();
            if (cur != null){
                TreeNode temp = cur.left;
                cur.left = cur.right;
                cur.right = temp;
            }
            if (cur.left!=null){
                queue.add(cur.left);
            }
            if (cur.right != null){
                queue.add(cur.right);
            }
        }
        return root;
    }
}
```

# 101. 对称二叉树
https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-100-liked

给你一个二叉树的根节点 root ， 检查它是否轴对称。



示例 1：

![img_12.png](img_12.png)
输入：root = [1,2,2,3,4,4,3]
输出：true
示例 2：
![img_13.png](img_13.png)

输入：root = [1,2,2,null,3,null,3]
输出：false


提示：

树中节点数目在范围 [1, 1000] 内
-100 <= Node.val <= 100


进阶：你可以运用递归和迭代两种方法解决这个问题吗？

****

分治递归：

基本情况：为空或者只有一个节点天然对称

左右子树关于对称轴对称。

也就是要满足，

1. 根节点必须相等
2. left_tree的左子树要和right_tree的右子树对称
3. left_tree的右子树要和right_tree的左子树对称

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

 public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
     }
 }

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        return help(root.left,root.right);
    }
    private boolean help(TreeNode node1,TreeNode node2){
        if ((node1 == null && node2!=null) ||(node1 != null && node2 == null)){
            return false;
        }
        if (node1 == null && node2 == null){
            return true;
        }
        if (node1.val == node2.val){
            return help(node1.left,node2.right) && help(node1.right,node2.left);
        }else {
            return false;
        }
    }
}
```

时间复杂度：O(n).递归树中最坏每个节点要调用一次，每个节点的本地调用都是O(1)

空间：O(n),递归到叶节点返回。最差情况退化成两个链表，深度O(n/2)

如下

```
      1
     / \
    2   2
   /     \
  3       3
 /         \
4           4
```

实际上上面的方法算是一种深度优先。先深入两条路径直到叶节点比较是否对称

2. 迭代，BFS

使用一个队列，一次镜像入队，比较节点值是否相同

```java
 import java.util.LinkedList;
import java.util.Queue;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode() {
    }

    TreeNode(int val) {
        this.val = val;
    }

    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);
        while (!queue.isEmpty()){
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            if (left == null && right == null){
                continue;
            }
            if (left == null || right == null){
                return false;
            }
            if (left.val != right.val){
                return false;
            }
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }
        return true;
    }
    
}

```
时间复杂度: O(n)。每个节点都要出队入队比较一次，非叶节点还要访问子节点，都是常数操作

空间复杂度：O(n).队列最大是叶节点，O(2^(logn)) = O(n)