# 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

双指针问题。  
慢指针指向非零元素应当被放置的地方，快指针负责遍历整个数组寻找非零元素  


```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        int fast = 0;
        while (fast < nums.length)
        {
            if (nums[fast] != 0)
            {
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
            fast++;
        }
    }
}
```
优化，减少操作次数，只有slow和fast不重合才交换    
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        int fast = 0;
        while (fast < nums.length)
        {
            if(nums[fast] != 0 )
            {
                if(fast != slow) {
                    int temp = nums[fast];
                    nums[fast] = nums[slow];
                    nums[slow] = temp;

                }
                slow++;//不管是否交换，只要发现了一个非零数字，不论是否进行了交换，slow原本指向的位置已经被处理过了，向右移动到下一个非零数字应当存放的位置
            }
            fast++;
        }
    }
}
```
注意索引要小于数组长度不能去等

## 盛水容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

![img.png](img.png)
```java
class Solution {
    public int maxArea(int[] height) {
        int i = 0;
        int j = height.length - 1;
        int result = (j - i) * Math.min(height[i],height[j]);
        while (i < j)
        {
            int resultThisLoop;
            if(height[i] <= height[j])
            {
                i++;
            }else{
                j--;
            }
            resultThisLoop = (j - i) * Math.min(height[i],height[j]);
            result = Math.max(result,resultThisLoop);
        }
        return result;
    }
}
```
风格可以优化一下

```java
class Solution {
    public int maxArea(int[] height) {
        int i = 0;
        int j = height.length - 1;
        int result = 0; // 初始化最大值为0
        while (i < j) {
            // 计算当前指针组合的面积
            int area = (j - i) * Math.min(height[i], height[j]);
            // 更新最大面积
            result = Math.max(result, area);
            
            // 移动指向较短线的指针
            if (height[i] <= height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return result;
    }
}
```