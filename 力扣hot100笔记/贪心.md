# 121. 买卖股票的最佳时机
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-100-liked
给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。



示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104


***

对于每一天，如果我们选择在今天卖出，那么我们应该在今天之前的最低价格买入。

我们考虑固定卖出的日子，是因为这样我们需要的是之前遍历过的最低的，我们只需要回顾历史信息不需要预测还未遍历的信息。反之如果固定买入的日子，需要预测还未遍历过的信息。

这样就把问题转化为一个可以在迭代中、仅利用历史信息就能做出最优决策的形式。

遍历同时维护最小值，时刻更新差即可。最终差和0比较

```java
import java.util.Map;

class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length < 2) {
            return 0;
        }

        int minPriceBefore = prices[0];
        int maxIncome = Integer.MIN_VALUE;
        for (int i = 1; i < prices.length; i++) {
            maxIncome = Math.max(maxIncome,prices[i] - minPriceBefore);
            minPriceBefore = Math.min(minPriceBefore,prices[i]);
        }
        return Math.max(0,maxIncome);
    }
}
```
时间O(n),空间O(1)

# 55. 跳跃游戏

https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-100-liked

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。



示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。


提示：

1 <= nums.length <= 104
0 <= nums[i] <= 105

******

感觉是个动态规划

状态定义为i，当前位于的坐标

dp[i]表示能否到达索引为i

dp[i] = 求或集(dp[k] && k + nums[k] >= i) ，i从0到i-1

复杂度，0+1+2+……n-1是O(n^2)

空间复杂度O(n)

DP思路是：dp[i] = OR(dp[k] && k + nums[k] >= i) for 0 <= k < i。

我们来观察这个式子：为了让 dp[i] 为 true，我们只需要存在任何一个 k 满足条件即可。

我们不必每次都回头检查所有的 k。我们可以一边遍历，一边维护一个变量 maxReach，这个变量记录了 max(k + nums[k])，其中 k 是所有已经确认为可达（dp[k]为true）的位置。

那么，判断 dp[i] 是否为 true，就等价于判断 i 是否小于等于 i-1 计算出的 maxReach。


事实上贪心算法

1. 贪心

维护一个maxReach，表示当前可以抵达的最远距离

遍历数组

对于每个位置，先判断是否可以抵达，不可以直接返回false；更新maxReach，如果maxReach大于最远坐标直接返回true。

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums.length <= 1){
            return true;
        }
        int maxReach = 0;
        for (int i = 0; i < nums.length; i++) {
            if (maxReach < i){
                return false;
            }
            maxReach = Math.max(maxReach,i + nums[i]);
            if (maxReach >= nums.length-1){
                return true;
            }
        }
        return true;
    }
}
```
时间O(n),空间O(n)

# 45. 跳跃游戏 II

https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-100-liked

给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。

每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处：

0 <= j <= nums[i] 且
i + j < n
返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。



示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2


提示:

1 <= nums.length <= 104
0 <= nums[i] <= 1000
题目保证可以到达 n - 1

******

维护三个变量

jumps: 当前的跳跃次数。

current_end: 当前这一跳所能到达的最远边界。

farthest: 跳跃能到达的最远位置


假设我们已经用了 k 步，能到达的最远距离是 current_end。现在我们需要迈出第 k+1 步。

我们的出发点可以是上一步能到达的任何位置（即从上一个边界到 current_end 之间的所有位置）。

在所有这些可能的出发点中，我们选择那个能让第 k+1 步跳完后，总覆盖范围最远的那个。

这个“最远的覆盖范围”就是 farthest 变量所记录的。

递推可以得到每次我们都能得到第j次跳跃所能达到的最远距离

直到这个边界大于等于终点

具体流程

1.  初始化 `jumps = 0`, `current_end = 0`, `farthest = 0`。
2.  我们从左到右遍历数组（从 `i = 0` 到 `n-2`，因为到达倒数第二个位置时，总能跳到最后一个位置，无需再更新）。
3.  在遍历每个位置 `i` 时，我们更新 `farthest` 的值，`farthest = max(farthest, i + nums[i])`。这代表了从第 `jumps` 次跳跃的覆盖范围内（即 `0` 到 `current_end`），再跳一次能到达的最远距离。
4.  当 `i` 到达了 `current_end` 时，意味着我们已经走完了上一次跳跃能覆盖的所有范围。此时，我们必须进行下一次跳跃。
    *   我们将 `jumps` 加 1。
    *   我们将 `current_end` 更新为新的 `farthest`，这为下一次跳跃设定了新的边界。
5.  遍历结束后，`jumps` 就是到达终点的最小跳跃次数。

```java
class Solution {
    public int jump(int[] nums) {
        int jumps = 0;
        int current_end = 0;
        int farthest = 0;
        for (int i = 0; i < nums.length - 1; i++) {
            farthest = Math.max(farthest,i+nums[i]);
            if (i == current_end){
                jumps++;
                current_end = farthest;
            }
        }
        return jumps;
    }
}
```
时间O(N)空间O(1)