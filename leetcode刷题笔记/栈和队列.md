# 栈和队列
## 20有效的括号
核心特征是** “后进先出”（Last-In, First-Out, LIFO）**。遇到的最后一个左括号，一定需要被最先遇到的右括号给匹配掉。
比如字符串 "{[]}"：

遇到 {，放进一个“等待区”。

接着遇到 [，也放进“等待区”。现在“等待区”里有 { 和 [，其中 [ 是后进去的。

然后遇到 ]，需要检查它是否能和“等待区”里最后进去的那个括号 [匹配。答案是可以，所以你把 [ 从“等待区”拿走。

最后遇到 }，你需要检查它是否能和“等待区”里剩下的最后一个括号 { 匹配。答案也是可以，所以你把 { 也拿走。

字符串遍历结束，“等待区”也空了，说明所有括号都完美匹配。这个“等待区”就是栈。

### 所以，流程如下：
创建一个栈（Stack）。

遍历输入的字符串 s 中的每一个字符。

如果字符是左括号 ((, [, {)：将它入栈（push）。

如果字符是右括号 (), ], }):

首先检查栈是否为空。如果为空，说明没有对应的左括号，直接返回 false。

如果栈不为空，将栈顶元素出栈（pop），并检查这个出栈的左括号是否与当前的右括号匹配。

如果不匹配，直接返回 false。

遍历完整个字符串后，检查栈是否为空。

如果栈是空的，说明所有的左括号都找到了匹配的右括号，返回 true。

如果栈不为空，说明还有多余的左括号没有被匹配，返回 false。
### java实现
```java
class Solution {
    public boolean isValid(String s) {
        // 如果字符串长度为奇数，肯定无效
        if (s.length() % 2 != 0) {
            return false;
        }

        // 创建一个栈
        Stack<Character> stack = new Stack<>();
        
        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 如果是左括号，入栈
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } 
            // 如果是右括号
            else {
                // 此时如果栈为空，说明没有对应的左括号
                if (stack.isEmpty()) {
                    return false;
                }
                
                // 弹出栈顶元素进行匹配
                char top = stack.pop();
                if (c == ')' && top != '(') {
                    return false;
                }
                if (c == ']' && top != '[') {
                    return false;
                }
                if (c == '}' && top != '{') {
                    return false;
                }
            }
        }
        
        // 遍历结束后，如果栈为空，则是有效的括号
        return stack.isEmpty();
    }
}

```
### 复杂度
时间O(N),空间O(N)



