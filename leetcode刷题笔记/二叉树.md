# 中序遍历leetcode第94题
我的第一次题解，是错误的
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List <Integer> result = new ArrayList<>();
        if(root == null)
        {
            return result;
        }
        inorderTraversal(root.left);
        result.add(root.val);
        inorderTraversal(root.right);
        return result;
    }
}
```
把result定义在了函数内部，因此每次递归调用无论如何都会创建一个新的result，覆盖原本需要的result
<br>更好的做法是使用辅助函数

```java
import javax.swing.tree.TreeNode;
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        inorderHelper(root,result);
        return result;
    }
    private void inorderHelper(TreeNode node,List<Integer> result){
        if(node == null)
        {
            return;
        }
        inorderHelper(node.left,result);
        result.add(node.val);
        inorderHelper(node.right,result);
    }
}
```
时间复杂度是O(N)<br>
空间复杂度也是O(N).result永远是O(N),调用栈理想时是O(logN),非理想时是O(N)

下面是迭代解法，需要我们手动维护一个stack

```java
import javax.swing.tree.TreeNode;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        //创建一个stack，用来保存需要返回去处理的父节点
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        /*
         只要当前节点非空，并且stack非空（也就是依然有存留的父节点需要处理）
         我们就继续循环       
         */
        while (current != null || !stack.isEmpty()){
            //先一直向左走，把经过的节点都入栈稍后处理
            while (current != null){
                stack.push(current);
                current = current.left;
            }
            //如果到了最左边，我们需要往回走
            //也就是完成了递的过程接下来要归
            current = stack.pop();
            result.add(current.val);
            //去处理右子树
            current = current.right;
        }
        return result;
    }
}
```
时间复杂度O(N):每个节点都会被入栈出栈各一次，也只进行O(1)的操作（访问left，right,val,add)
<br>
空间复杂度，最坏为O(N):主要看stack，退化成链表就是O(N)，平均情况是O(logN).
<br>
**还有个Morris 遍历法，日后再学习吧。**