# 概念
## 定义
通过穷举来解决问题的方法，核心思想是从一个初始状态除法，暴力搜索所有可能的解决方案，遇到正确的解记录，直到找到解或者尝试所有可能无法找到解  
经常使用深度优先搜索  
## 尝试与回退
经常使用这两个策略，遇到某个状态无法前进就撤销上一步选择  
例如，`给定一棵二叉树，搜索并记录所有值为7的节点，请返回节点列表。`
```java
/* 前序遍历：例题一 */
void preOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    if (root.val == 7) {
        // 记录解
        res.add(root);
    }
    preOrder(root.left);
    preOrder(root.right);
}
```
访问每个节点都表示尝试，越过叶节点return表示回退  
但回退不仅仅包括函数返回
例，`在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径。`
```java
/* 前序遍历：例题二 */
void preOrder(TreeNode root) {
    if (root == null) {
        return;
    }
    // 尝试
    path.add(root); //path 需要在外部定义
    if (root.val == 7) {
        // 记录解
        res.add(new ArrayList<>(path));
    }
    preOrder(root.left);
    preOrder(root.right);
    //回退，到最后遍历了root以及他的所有子节点也没找到，需要把root从path去掉
    path.remove(path.size() - 1);

    path.remove(path.size() - 1);
}
```
这里我们信仰之越的契约是：相信preOrder能处理更小规模的子树，遍历子树的root以及所有节点，并把路径添加到res，让后穷举完所有结果后回退，把path回退到之前
## 剪枝
如果有约束条件可以尝试剪枝  
例，`在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3 的节点。`  
我们需要添加剪枝操作，遇到值为3的节点则提前返回不再继续找

```java
import javax.swing.tree.TreeNode;
import java.util.ArrayList;

void preOrder(TreeNode root) {
    //剪枝
    if (root == null || root.val == 3) {
        return;
    }
    //尝试
    path.add(root);
    if (root.val == 7) {
        //记录解
        res.add(new ArrayList<>(path));
    }
    //继续尝试左右边
    preOrder(root.left);
    preOrder(root.right);
    //回退
    path.remove(path.size() - 1);
}
```
![img_12.png](img_12.png)

## 框架代码

